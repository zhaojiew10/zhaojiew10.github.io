<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="参考资料  https:&#x2F;&#x2F;blog.csdn.net&#x2F;TZ845195485&#x2F;article&#x2F;details&#x2F;119745735  Redis单线程和多线程问题的背景Redis里程碑版本迭代  Redis的单线程 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个顺序串行的主线程">
<meta property="og:type" content="article">
<meta property="og:title" content="理解redis的多线程和IO多路复用">
<meta property="og:url" content="http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/index.html">
<meta property="og:site_name" content="zhaojiew&#39;s blog">
<meta property="og:description" content="参考资料  https:&#x2F;&#x2F;blog.csdn.net&#x2F;TZ845195485&#x2F;article&#x2F;details&#x2F;119745735  Redis单线程和多线程问题的背景Redis里程碑版本迭代  Redis的单线程 主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个顺序串行的主线程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/06/20/J54s2bDdjFhyzIH.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/20/rxC3En54WqwuoGy.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/20/Y6XcB3nxPljRUa4.png">
<meta property="og:image" content="https://camo.githubusercontent.com/57e7cbeab41ca9576193a190221562a64eed76c089bae42c72d92ebc5c65e018/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f32382f4c31473575726264394e48594973682e706e67">
<meta property="og:image" content="https://s2.loli.net/2023/06/21/yTvIa1oEkeWSO42.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/21/Em3O25ZgsifoGLF.png">
<meta property="og:image" content="https://camo.githubusercontent.com/c6e6fa55a4512ce9e903ff05a5be669379cbaa03c65b81c9d110d408d752bc3b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f34626331346436343765333736363163353039613336323536363035643761652e706e67">
<meta property="og:image" content="https://s2.loli.net/2023/06/23/hNWTbzLn5sxX2lO.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/23/QWFjZlLKeRn59Nm.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/23/9fDJGERhlCjNtUX.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/23/DmKne2ucrO9LY5J.png">
<meta property="article:published_time" content="2023-06-30T04:12:57.000Z">
<meta property="article:modified_time" content="2024-02-19T03:21:59.583Z">
<meta property="article:author" content="zhaojiew">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/20/J54s2bDdjFhyzIH.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>理解redis的多线程和IO多路复用</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="zhaojiew&#39;s blog" type="application/atom+xml" />
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zhaojiew10">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&text=理解redis的多线程和IO多路复用"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&is_video=false&description=理解redis的多线程和IO多路复用"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=理解redis的多线程和IO多路复用&body=Check out this article: http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&name=理解redis的多线程和IO多路复用&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&t=理解redis的多线程和IO多路复用"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">Redis单线程和多线程问题的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Redis的单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Redis为什么选择单线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%88%A9%E7%94%A8%E5%A4%9A%E6%A0%B8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Redis为什么开始利用多核？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BD%93%E5%89%8D%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="toc-number">1.4.</span> <span class="toc-text">Redis当前的性能瓶颈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%92%8CIO%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%90%8C"><span class="toc-number">1.5.</span> <span class="toc-text">Redis的主线程如何和IO线程协同</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">IO多路复用的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">深入理解Redis的IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ebio%EF%BC%8Cnio%E5%88%B0io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">解释为什么从bio，nio到io多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何解决服务器主线程阻塞的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">如何解决多线程资源浪费的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3NIO%E6%A8%A1%E5%9E%8Bcpu%E4%B8%8D%E5%8F%8B%E5%A5%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">如何解决NIO模型cpu不友好的问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">IO多路复用的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">select方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">poll方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">epoll方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.4.</span> <span class="toc-text">三个方法的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elasticache7%E7%9A%84%E5%A2%9E%E5%BC%BAIO"><span class="toc-number">4.</span> <span class="toc-text">elasticache7的增强IO</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        理解redis的多线程和IO多路复用
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">zhaojiew</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-06-30T04:12:57.000Z" class="dt-published" itemprop="datePublished">2023-06-30</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/redis/">redis</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/redis/" rel="tag">redis</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/TZ845195485/article/details/119745735">https://blog.csdn.net/TZ845195485/article/details/119745735</a></li>
</ul>
<h1 id="Redis单线程和多线程问题的背景"><a href="#Redis单线程和多线程问题的背景" class="headerlink" title="Redis单线程和多线程问题的背景"></a>Redis单线程和多线程问题的背景</h1><p>Redis里程碑版本迭代</p>
<p><img src="https://s2.loli.net/2023/06/20/J54s2bDdjFhyzIH.png"></p>
<h2 id="Redis的单线程"><a href="#Redis的单线程" class="headerlink" title="Redis的单线程"></a>Redis的单线程</h2><ul>
<li><p>主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时<strong>包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个顺序串行的主线程处理</strong>，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。</p>
</li>
<li><p>但Redis的其他功能，比如持久化RDB、AOF、异步删除、集群数据同步等等，其实是由额外的线程执行的。</p>
</li>
<li><p><font color=red><strong>Redis命令工作线程是单线程的，但是整个Redis来说是多线程的</strong></font></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/06/20/rxC3En54WqwuoGy.png"></p>
<h2 id="Redis为什么选择单线程？"><a href="#Redis为什么选择单线程？" class="headerlink" title="Redis为什么选择单线程？"></a>Redis为什么选择单线程？</h2><ul>
<li><strong>基于内存操作</strong>：Redis的所有数据都存在内存中，因此所有的运算都是内存级别的，性能比较高；</li>
<li><strong>数据结构简单</strong>：Rdis的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是O(1)，因此性能比较高</li>
<li><strong>多路复用和非阻塞I&#x2F;O</strong>：Redis使用I&#x2F;O多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，避免了IO阻塞操作</li>
<li><strong>避免上下文功换</strong>：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗</li>
</ul>
<h2 id="Redis为什么开始利用多核？"><a href="#Redis为什么开始利用多核？" class="headerlink" title="Redis为什么开始利用多核？"></a>Redis为什么开始利用多核？</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://redis.io/docs/getting-started/faq/#how-can-redis-use-multiple-cpus-or-cores">https://redis.io/docs/getting-started/faq/#how-can-redis-use-multiple-cpus-or-cores</a></p>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound.</p>
<p>As of version 4.0, Redis has started implementing threaded actions. For now this is limited to deleting objects in the background and blocking commands implemented via Redis modules. For subsequent releases, the plan is to make Redis more and more threaded.</p>
</blockquote>
<p>使用多核的必要性</p>
<ul>
<li><p>Redis4.0引入异步删除，在删除大key时，单线程会出现阻塞（类似synchronized锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unlink key</span><br><span class="line">flushdb async</span><br><span class="line">flushall async</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用惰性删除避免阻塞。因为Redis是单个主线程处理，而<code>lazy free</code>的本质就是把某些cost（主要时间复制度，占用主线程cpu时间片）较高删除操作，从redis主线程剥离让bio子线程来处理，极大地减少主线阻塞时间。从而减少删除导致性能和稳定性问题。</p>
</li>
</ul>
<h2 id="Redis当前的性能瓶颈"><a href="#Redis当前的性能瓶颈" class="headerlink" title="Redis当前的性能瓶颈"></a>Redis当前的性能瓶颈</h2><ul>
<li><p>redis主要的性能瓶颈是内存或者网络IO，而不太可能是cpu</p>
</li>
<li><p>虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写）。但是从网络IO处理到实际的读写命令处理，都是由单个线程完成的。</p>
</li>
<li><p>单个主线程处理网络请求的速度跟不上底层网络硬件的速度，为了应对这个问题采用多个IO线程来处理网络请求，提高网络请求处理的并行度，Rdis6&#x2F;7就是采用的这种方法。</p>
<blockquote>
<p>但是，Redis的多IO线程只是用来处理网络请求的，对于读写操作命令Redis仍然使用单线程来处理。这是因为Redis处理请求时，网络处理经常是瓶颈，<strong>通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥加锁机制</strong>，这样一来Redis线程模型实现就简单了</p>
</blockquote>
</li>
</ul>
<h2 id="Redis的主线程如何和IO线程协同"><a href="#Redis的主线程如何和IO线程协同" class="headerlink" title="Redis的主线程如何和IO线程协同"></a>Redis的主线程如何和IO线程协同</h2><p>既然瓶颈是网络IO，Redis的主线程如何和IO线程协同？</p>
<ol>
<li><strong>服务端和客户端建立Socket连接，并分配处理线程</strong>。首先，主线程负责接收建立连接请求。当有客户端请求和实例建立Socket连接时，主线程会创健和客户的连接，并把Socket放入全局等待队列中。紧接看主线程通过轮询方法把Socket连接分配给IO线程</li>
<li><strong>IO线程读取并解折请求</strong>。主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求读取和解析。因为有多个IO线程在并行处理，所似这个过程很快完成</li>
<li><strong>主线程执行请求操作</strong>。等IO线程解析完请求，主线程以单线程的方式执行这些命令操作。</li>
<li><strong>IO线程回写Socket和主当主线程清空全局队列</strong>。主线程执行完请求操作后，会把需要返回的结果写入缓冲区，然后主线程会阻塞等待IO线程，把这些结果回写到Socket中（多个线程在并发执行），并返回给客户端。等到lO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。</li>
</ol>
<p><img src="https://s2.loli.net/2023/06/20/Y6XcB3nxPljRUa4.png"></p>
<h1 id="IO多路复用的理解"><a href="#IO多路复用的理解" class="headerlink" title="IO多路复用的理解"></a>IO多路复用的理解</h1><p><a target="_blank" rel="noopener" href="https://github.com/zhojiew/aws-learning-notebook/blob/main/reprint%26forward/%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB.md">linux的5种IO模型的理解</a></p>
<blockquote>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/57e7cbeab41ca9576193a190221562a64eed76c089bae42c72d92ebc5c65e018/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f32382f4c31473575726264394e48594973682e706e67"><img src="https://camo.githubusercontent.com/57e7cbeab41ca9576193a190221562a64eed76c089bae42c72d92ebc5c65e018/68747470733a2f2f73322e6c6f6c692e6e65742f323032332f30352f32382f4c31473575726264394e48594973682e706e67" alt="img"></a></p>
<p>IO多路复用的解释，即使用<strong>一个或一组线程处理多个tcp连接</strong></p>
<ul>
<li>IO，指代网络IO，需要进行模态转换的读写操作</li>
<li>多路，多个客户端连接（socket）</li>
<li>复用，复用一个或多个线程、</li>
</ul>
<p>一个服务端进程可以同时处理多个socket，IO多路复用模型包括select，poll，epoll</p>
<p><strong>在单个线程通过记录跟踪每一个Sockek（I&#x2F;O流）的状态来同时管理多个I&#x2F;O流。一个服务端进程可以同时处理多个套接字描述符。</strong>目的是尽量多的提高服务器的吞吐能力。</p>
<blockquote>
<p>将用户socket对应的文件描述符（FileDescriptor）注册进epoll，然后epoll监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的<strong>socket应该采用非阻塞模式</strong>。这样整个过程只在调用select.、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p>
</blockquote>
<p><strong>因此IO多路复用+epoll也是Redis速度快的根本保证</strong>。redis的多线程即</p>
<ul>
<li>单个工作线程保证线程安全和高性能</li>
<li>多个IO线程解决网络IO的问题</li>
</ul>
<p><img src="https://s2.loli.net/2023/06/21/yTvIa1oEkeWSO42.png"></p>
<p>在redis6&#x2F;7中，IO多路复用默认是关闭的，有2个相关的配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################### THREADED I/O #################################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis is mostly single threaded, however there are certain threaded</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">operations such as UNLINK, slow I/O accesses and other things that are</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">performed on side threads.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Now it is also possible to handle Redis clients socket reads and writes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> different I/O threads. Since especially writing is so slow, normally</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis <span class="built_in">users</span> use pipelining <span class="keyword">in</span> order to speed up the Redis performances per</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">core, and spawn multiple instances <span class="keyword">in</span> order to scale more. Using I/O</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">threads it is possible to easily speedup two <span class="built_in">times</span> Redis without resorting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to pipelining nor sharding of the instance.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># By default threading is disabled, we suggest enabling it only in machines</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that have at least 4 or more cores, leaving at least one spare core.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Using more than 8 threads is unlikely to <span class="built_in">help</span> much. We also recommend using</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">threaded I/O only <span class="keyword">if</span> you actually have performance problems, with Redis</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">instances being able to use a quite big percentage of CPU time, otherwise</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">there is no point <span class="keyword">in</span> using this feature.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># So for instance if you have a four cores boxes, try to use 2 or 3 I/O</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">threads, <span class="keyword">if</span> you have a 8 cores, try to use 6 threads. In order to</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> I/O threads use the following configuration directive:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># io-threads 4</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Setting io-threads to 1 will just use the main thread as usual.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When I/O threads are enabled, we only use threads <span class="keyword">for</span> writes, that is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to thread the write(2) syscall and transfer the client buffers to the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socket. However it is also possible to <span class="built_in">enable</span> threading of reads and</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protocol parsing using the following configuration directive, by setting</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it to <span class="built_in">yes</span>:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># io-threads-do-reads no</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Usually threading reads doesn&#x27;t help much.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># NOTE 1: This configuration directive cannot be changed at runtime via</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG SET. Also, this feature currently does not work when SSL is</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">enabled.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># NOTE 2: If you want to test the Redis speedup using redis-benchmark, make</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sure you also run the benchmark itself <span class="keyword">in</span> threaded mode, using the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--threads option to match the number of Redis threads, otherwise you<span class="string">&#x27;ll not</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">be able to notice the improvements.</span></span></span><br></pre></td></tr></table></figure>

<p><strong>线程数不要超过机器的核心数</strong></p>
<h1 id="深入理解Redis的IO多路复用"><a href="#深入理解Redis的IO多路复用" class="headerlink" title="深入理解Redis的IO多路复用"></a>深入理解Redis的IO多路复用</h1><p>Redis利用epoll来实现IO多路复用，<strong>将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</strong></p>
<p><img src="https://s2.loli.net/2023/06/21/Em3O25ZgsifoGLF.png">Rdis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以I&#x2F;O操作在一般情况下往往不能直接返回，这会导致某一文件的I&#x2F;O阻塞导致整个进程无法对其它客户提供服务，而I&#x2F;O多路复用就是为了解决这个问题而出现</p>
<p>所谓I&#x2F;O多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪)，能够通知程序进行相应的读写操作。这种机制的使用需要select、pol川、epol来配合。多个连接共用一个阻塞对象，<strong>应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</strong></p>
<p>Redis服务采用Reactor的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符</p>
<p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>。它的组成结构为4部分：</p>
<ul>
<li>多个套接字</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器。</li>
</ul>
<p><strong>因为文件事件分派器队列的消费是单线程的，所汉Reds才叫单线程模型</strong></p>
<h2 id="解释为什么从bio，nio到io多路复用"><a href="#解释为什么从bio，nio到io多路复用" class="headerlink" title="解释为什么从bio，nio到io多路复用"></a>解释为什么从bio，nio到io多路复用</h2><p>在bio场景下，当client1请求并和server建立连接后，server在accept和read处发生阻塞，此时新的client2建立连接的请求无法被server处理（处于阻塞中）</p>
<p>注意：<strong>这里的应用程序指代的是server端</strong></p>
<h3 id="如何解决服务器主线程阻塞的问题？"><a href="#如何解决服务器主线程阻塞的问题？" class="headerlink" title="如何解决服务器主线程阻塞的问题？"></a>如何解决服务器主线程阻塞的问题？</h3><p>考虑使用子线程来处理新的客户端连接和请求。在连接socket后创建线程来处理read操作</p>
<p>client代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scoket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">OutputStream outputStream == socket.getOUtputStream();</span><br><span class="line"><span class="comment">// 获取标准输入到msg</span></span><br><span class="line">outputStream.write(msg.getBytes());</span><br></pre></td></tr></table></figure>

<p>server代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6379</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept(); <span class="comment">// 阻塞等待连接</span></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">			<span class="comment">// 从input中获取输入，阻塞在读请求</span></span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,Thread.currentThread().getName()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何解决多线程资源浪费的问题"><a href="#如何解决多线程资源浪费的问题" class="headerlink" title="如何解决多线程资源浪费的问题"></a>如何解决多线程资源浪费的问题</h3><p>多线程模型要求每到来一个请求，就切换到内核态创建对应的的进程。新的进程和上下文切换都会产生性能的损耗</p>
<ul>
<li>池化技术，但是实际的线程数量未知</li>
<li>NIO，使read方法不阻塞</li>
</ul>
<p><strong>NIO的特点是使用轮询替代阻塞</strong></p>
<p><img src="https://camo.githubusercontent.com/c6e6fa55a4512ce9e903ff05a5be669379cbaa03c65b81c9d110d408d752bc3b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f34626331346436343765333736363163353039613336323536363035643761652e706e67" alt="img"></p>
<p>在客户端，如果kernal中的数据没有准备好，则会返回error</p>
<p><strong>在NIO中一切都是非阻塞的</strong></p>
<ul>
<li>accept方法非阻塞，如果没有客户端连接则返回无连接标识</li>
<li>read方法非阻塞，如果read读不到数据返回空间中标识，有数据则只阻塞read读取数据的时间</li>
<li><strong>nio中服务端只有一个线程，对socker数组进行遍历</strong></li>
</ul>
<p>客户端代码和bio下相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scoket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">OutputStream outputStream == socket.getOUtputStream();</span><br><span class="line"><span class="comment">// 获取标准输入到msg</span></span><br><span class="line">outputStream.write(msg.getBytes());</span><br></pre></td></tr></table></figure>

<p>服务端代码</p>
<ul>
<li>通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li>
<li>通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ArrayList&lt;SocketChannel&gt; socketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 容纳socket数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 输入缓冲</span></span><br><span class="line"></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocketChannel</span>.open();</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,<span class="number">6379</span>));</span><br><span class="line">serverSocket.configureBlocking(<span class="literal">false</span>); <span class="comment">// jdk1.4开始兼容阻塞模式，此处设置为非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span> (SocketChannel element : socketList)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span>  <span class="operator">=</span> element.read(byteBuffer); <span class="comment">//不会阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(read &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[read];</span><br><span class="line">            byteBuffer.get(<span class="type">byte</span>);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocket.accpet(); <span class="comment">// 不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="literal">null</span>)&#123;</span><br><span class="line">        sockerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketList.add(socketChannel) <span class="comment">// 连接成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO模型存在的问题</p>
<ul>
<li>socketlist遍历存在性能瓶颈（空socket仍旧会轮询），cpu不友好</li>
<li>对socket状态的判断仍旧需要切换模态（查询socket仍旧是通过read syscall），开销较大、</li>
<li>轮询会不断询问内核，占用了大量cpu时间，系统资源利用率较低</li>
</ul>
<h3 id="如何解决NIO模型cpu不友好的问题？"><a href="#如何解决NIO模型cpu不友好的问题？" class="headerlink" title="如何解决NIO模型cpu不友好的问题？"></a>如何解决NIO模型cpu不友好的问题？</h3><p><font color=red><strong>如果通过linux内核完成上述工作（遍历socket），不需要模态切换，内核本身是非阻塞的</strong>。</font></p>
<p><strong>多路复用就是使用一个信道传输多个信号，多个网络连接使用一个线程，多个socket使用一个通道是在内核和驱动层实现的</strong></p>
<p>IO多路复用模型</p>
<p><img src="https://s2.loli.net/2023/06/23/hNWTbzLn5sxX2lO.png"></p>
<p>基于I&#x2F;O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p><strong>Reactor模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式</strong>。服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式。即I&#x2F;O多了复用统一监听事件，收到事件后分发（Dispatch给某进程），是编写高性能网络服务器的必备技术。Reactor模式中有2个关键组成：</p>
<ul>
<li>Reactor，Reactor在一个单独的线程中运行，负贵监听和分发事件，分发给适当的处理程序来对IO事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>
<li>Handlers，处理程序执行I&#x2F;O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际办理人。Reactor通过调度适当的处理程序来响应I&#x2F;O事件，处理程序执行非阻塞操作</li>
</ul>
<div align=center><img src="https://s2.loli.net/2023/06/23/QWFjZlLKeRn59Nm.png" style="zoom:67%;" /></div>

<h2 id="IO多路复用的具体实现"><a href="#IO多路复用的具体实现" class="headerlink" title="IO多路复用的具体实现"></a>IO多路复用的具体实现</h2><h3 id="select方法"><a href="#select方法" class="headerlink" title="select方法"></a>select方法</h3><p><img src="https://s2.loli.net/2023/06/23/9fDJGERhlCjNtUX.png"></p>
<p>select函数监视的文件描述符分3类，分别是<code>readfds、writefds和exceptfds</code>，将用户传入的数组拷贝到内核空间</p>
<ul>
<li><p><strong>调用后select函数会阻塞，直到有描述符就绪</strong>（有数据可读、可写、或者有except）或超时（timeout指定等待时间，如果立即返回设为null即可），函数返回</p>
</li>
<li><p>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
</li>
</ul>
<p>分析select函数的执行流程：</p>
<ol>
<li>select是一个阻塞函数，当没有数据时，会一直阻塞在select调用</li>
<li>当有数据时会将rset中对应的位置为1</li>
<li>selecti函数返回，不再阻塞</li>
<li>遍历文件描述符数组，判断哪个fd被置位</li>
<li>读取数据，然后处理</li>
</ol>
<p>下面的示例代码</p>
<ul>
<li><p><strong>实际是将之前java示例的代码从用户态搬到内核态运行</strong></p>
</li>
<li><p>将<code>fd</code>拷贝到内核态，避免模态切换</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">memse(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">listen (sockfd, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i+)&#123;</span><br><span class="line">	<span class="comment">// 模拟5个客户端连接</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>,<span class="keyword">sizeof</span> (client)); </span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    fds[i] = accept(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i]&gt;max)</span><br><span class="line">        max = fds[i]; <span class="comment">//找到一个最大的文件描述符，在下面select中限制范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	FD_ZERO(&amp;rset); <span class="comment">// 重置rset为0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        FD_SET(fds[i],&amp;rset); <span class="comment">// &amp;rset是个bitmap.如果5个文件描述符分别是1,2,4,5,7,那么这个bitmap为01101101</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);  </span><br><span class="line">    select(max+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">// select是一个系统调用,它会堵塞直到有数据发送到socket,select会把&amp;rset相应的位置置位,但并不会返回哪个socket有数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 用户态只要遍历&amp;rst,看哪一位被置位了,不需要每次调用系统调用来判断了,效率有很大提升,遍历到被置位的文件描述符就进行读取</span></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fds[i],&amp;rset))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, MAXBUF);</span><br><span class="line">        read(fds[i], buffer, MAXBUF);</span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select函数的缺点</p>
<ul>
<li>bitmap默认大小为1024（代码实现较早1983年），虽然可以调整但还是有限度的</li>
<li>rset每次循环都必须重新置位为0，不可重复使用</li>
<li>尽管将rset从用户态拷贝到内核态由内核态判断是否有数据，但是还是有拷贝的开销</li>
<li>当有数据时select就会返回，但是selecti函数并不知道哪个文件描述符有数据了（仅仅置位）。后面还需要再次对文件描述符数组进行遍历，效率比较低</li>
</ul>
<h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds,<span class="type">nfds_t</span> nfds,<span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">fd</span>;</span> <span class="comment">//file descriptor </span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">// 读或者写事件</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">// 文件描述符有事件则置1 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>poll的执行流程:</p>
<ol>
<li>将五个fd从用户态拷贝到内核态</li>
<li>poll为阻塞方法，执行poll方法，如果有数据会将fd对应的revents置为POLLIN</li>
<li>poll方法返回</li>
<li>循环遍历，查找哪个fd被置位为POLLIN了</li>
<li>将revents重置为0便于复用</li>
<li>对置位的fd进行读取和处理</li>
</ol>
<p>解决的问题</p>
<ul>
<li>不在使用bitmap，消除了client的大小限制（1024）</li>
<li>rset不可复用的问题（每次置0）</li>
</ul>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="number">1</span>=<span class="number">0</span>;<span class="number">1</span>&lt;<span class="number">5</span>;<span class="number">1</span>++) <span class="comment">//模拟5个客户端连接</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>,<span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    pollfds[i].fd = accept(sockfd,(<span class="keyword">struct</span> sockaddr)&amp;client,&amp;addr);</span><br><span class="line">    pollfds[i].events = POLLIN; <span class="comment">//这5个socket只读事件</span></span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">    poll(po11fds,<span class="number">5</span>,<span class="number">50000</span>); <span class="comment">// poll中传入pollfds数组,交给内核判断是否有事件发生,如果哪个发生事件则revents置1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="number">1</span>=<span class="number">0</span>; <span class="number">1</span>&lt;<span class="number">5</span>; <span class="number">1</span>++)&#123; <span class="comment">//遍历数组,找到哪个pollfd有事件发生</span></span><br><span class="line">        <span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">        pollfds[i].revents=O; <span class="comment">// 找到后revents置0</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">        read(pollfds[i].fd,buffer,MAXBUF); <span class="comment">//读取数据</span></span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点</p>
<ul>
<li>本质上还是select方法</li>
<li>拷贝fd到内核态仍旧存在开销</li>
<li>仍旧需要遍历socket（O(n)复杂度）</li>
</ul>
<h3 id="epoll方法"><a href="#epoll方法" class="headerlink" title="epoll方法"></a>epoll方法</h3><p> 函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll的句柄，size表示内核监听的数目。并非最大限制，而是内核初始分配数据结构的建议值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 向内核添加，修改或删除要监控的fd</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd, <span class="comment">// epfd是epoll_create的返回值</span></span></span><br><span class="line"><span class="params">    <span class="number">1</span>nt op, <span class="comment">// 表示op操作,用三个宏来表示:添加EPOLL.CTL_ADD,除EPOLL.CTL_DEL,修改EPOLL.CTL_MOD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd, <span class="comment">//fd:是需要监听的fd(文件描述符)</span></span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> epoll_event *event <span class="comment">// 告诉内核要监听什么事</span></span></span><br><span class="line"><span class="params">)</span>; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">    // <span class="title">events</span>可以是以下几个宏的熊合:</span></span><br><span class="line">	<span class="comment">// EPOLLIN:表示对应的文件描述符可以读(包括对端SOCKET正常关闭);</span></span><br><span class="line">	<span class="comment">// EPOLLOUT:表示对应的文件描述符可以写;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">// User data variable </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似select调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll event *events,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents, <span class="comment">// 最多返回的事件数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>具体实现</p>
<ul>
<li>socket生命周期只会从用户态到内核态拷贝一次</li>
<li>使用event通知级值，<strong>每次socket有数据会主动通知内核加入就绪列表，不需要遍历所有socket</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"><span class="type">int</span> epfd <span class="title function_">epoll_create</span><span class="params">(<span class="number">10</span>)</span>; <span class="comment">// epoll_create在内核开辟一块内存空间,用来存放epolle中fd的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i+) &#123; <span class="comment">//模拟S个客户端连接</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span> <span class="comment">// epoll中fd的数据结构和polI中的差不多,只是没有了revents</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;client,<span class="number">0</span>,<span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen <span class="title function_">sizeof</span><span class="params">(client)</span>; </span><br><span class="line">    ev.data.fd = accept(sockfd,(<span class="keyword">struct</span> sockaddr&amp;client,&amp;addrlen);</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,ev.data.fd,&amp;ev); <span class="comment">// epoll ctl把每-个socket的fd数据结构放到epoll_create创建的内存空间中</span></span><br><span class="line">&#125;</span><br><span class="line">                      </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;round again&quot;</span>);</span><br><span class="line">    nfds = epoll_wait(epfd,events,<span class="number">5</span>,<span class="number">1</span>O0O0); <span class="comment">// epoll_wait阻塞,只有当epoll_create中创建的内存空间中的fd有事件发生,才会把这些fd放入就绪链表中,返回就绪fd的个数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++)&#123; <span class="comment">//遍历就绪链表,读取数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">        read(events[i].data.fd, buffer, MAXBUF);</span><br><span class="line">        <span class="built_in">puts</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个方法的对比"><a href="#三个方法的对比" class="headerlink" title="三个方法的对比"></a>三个方法的对比</h3><ul>
<li>不同操作系统选择的方式不同，windows没有epoll默认为select</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>数据结构</td>
<td>bitmap</td>
<td>数组</td>
<td>红黑树</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024或2048（x64）</td>
<td>无限</td>
<td>无限</td>
</tr>
<tr>
<td>最大支持fd数</td>
<td>无限</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>fd跨态拷贝</td>
<td>每次select调用都需要拷贝</td>
<td>每次poll调用都需要拷贝</td>
<td>首次调用epoll_ctl拷贝</td>
</tr>
<tr>
<td>工作效率</td>
<td>线性遍历，O(n)</td>
<td>线性遍历，O(n)</td>
<td>事件通知，O(1)</td>
</tr>
</tbody></table>
<h1 id="elasticache7的增强IO"><a href="#elasticache7的增强IO" class="headerlink" title="elasticache7的增强IO"></a>elasticache7的增强IO</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/blogs/china/enhanced-io-multiplexing-for-amazon-elasticache-for-redis/">Amazon ElastiCache for Redis 7 新增功能：通过增强型 I&#x2F;O 多路复用将吞吐量提升高达 72%</a></p>
</blockquote>
<p>使用 ElastiCache for Redis 7 时，将会免费自动提供增强型 I&#x2F;O 多路复用功能</p>
<p><img src="https://s2.loli.net/2023/06/23/DmKne2ucrO9LY5J.png"></p>
<p>采用增强型 I&#x2F;O 后，引擎将专注于处理命令的运行，而非处理网络连接。不再为每个客户端打开一个通道，而是如下图所示，由每个增强型 I&#x2F;O 线程使用 ElastiCache for Redis 引擎将命令组合在单个通道中</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/zhaojiew10">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">Redis单线程和多线程问题的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Redis的单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Redis为什么选择单线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%88%A9%E7%94%A8%E5%A4%9A%E6%A0%B8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Redis为什么开始利用多核？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BD%93%E5%89%8D%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="toc-number">1.4.</span> <span class="toc-text">Redis当前的性能瓶颈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E5%92%8CIO%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%90%8C"><span class="toc-number">1.5.</span> <span class="toc-text">Redis的主线程如何和IO线程协同</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">IO多路复用的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">深入理解Redis的IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%8Ebio%EF%BC%8Cnio%E5%88%B0io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">解释为什么从bio，nio到io多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何解决服务器主线程阻塞的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E6%B5%AA%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">如何解决多线程资源浪费的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3NIO%E6%A8%A1%E5%9E%8Bcpu%E4%B8%8D%E5%8F%8B%E5%A5%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">如何解决NIO模型cpu不友好的问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">IO多路复用的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">select方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">poll方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">epoll方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.4.</span> <span class="toc-text">三个方法的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elasticache7%E7%9A%84%E5%A2%9E%E5%BC%BAIO"><span class="toc-number">4.</span> <span class="toc-text">elasticache7的增强IO</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&text=理解redis的多线程和IO多路复用"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&is_video=false&description=理解redis的多线程和IO多路复用"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=理解redis的多线程和IO多路复用&body=Check out this article: http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&title=理解redis的多线程和IO多路复用"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&name=理解redis的多线程和IO多路复用&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/06/30/%E7%90%86%E8%A7%A3redis%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/&t=理解redis的多线程和IO多路复用"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    zhaojiew
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/zhaojiew10">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
